#include "merge.h"
#include "utils.h"
#include "branch_utils.h"
#include "checkout.h"
#include "commit_utils.h"
#include "merge_utils.h"

#include <filesystem>
#include <fstream>
#include <sstream>
#include <iostream>

namespace fs = std::filesystem;
constexpr const char* MERGE_STATE_PATH = ".minigit\\MERGE_STATE";

/**
* @brief 현재 index 파일의 내용을 string으로 읽음
*/
std::string getCurrentIndexSnapshot()
{
	return readFileContent(".minigit\\index");
}

/**
* @brief 주어진 커밋이 다른 커밋의 조상(ancestor)인지 확인
* 
* @param ancestor 조상인지 확인할 커밋 해시
* @paran descendant 탐색할 대상 커밋 해시
* @return true descendant가 ancestor의 자손일 경우
* @return false ancestor와 관련 없는 경우 (또는 경로 없음)
*/
bool isAncestor(const std::string& ancestor, const std::string& descendant)
{
	std::string current = descendant;
	while (!current.empty())
	{
		if (current == ancestor) return true;

		std::ifstream meta(".minigit\\commits\\" + current + "\\meta.txt");
		if (!meta.is_open()) break;

		std::string line;
		while (std::getline(meta, line))
		{
			// 메타 정보에서 parent 해시 추출
			if (line.rfind("parent: ", 0) == 0)
			{
				current = line.substr(8);
				break;
			}
		}

		meta.close();
	}

	return false;
}

/**
* @brief 지정한 브랜치를 현재 브랜치에 병합한다.
* @details fast-forward 방식만 지원하며, 충돌 처리 및 다중 부모 병합은 지원하지 않음
*
* @param targetBranch 병합 대상 브랜치 이름
*/
void mergeBranch(const std::string& targetBranch)
{
	std::string targetPath = ".minigit\\refs\\heads\\" + targetBranch;

	// 대상 브랜치가 존재하는지 확인
	if (!fs::exists(targetPath))
	{
		std::cerr << "병합 대상 브랜치가 존재하지 않습니다.\n";
		return;
	}


	// 병합 상태가 존재하는지 확인 (존재하면 리턴)
	if (fs::exists(MERGE_STATE_PATH))
	{
		std::cerr << "충돌 해결 후 merge [--abort | --continue] 명령어를 실행 시켜야합니다.\n";
		return;
	}


	// 병합 대상 브랜치의 커밋 해시 읽기
	std::string targetHash;
	std::ifstream in(targetPath);
	std::getline(in, targetHash);
	in.close();

	if (targetHash.empty())
	{
		std::cerr << "병합 대상 브랜치에 커밋이 없습니다.\n";
		return;
	}

	std::string currentHash = getCurrentBranchHash();
	std::string currentBranch = getCurrentBranchName();

	if (currentHash.empty() || targetHash.empty())
	{
		std::cerr << "병합 불가: 브랜치 커밋 정보 없음\n";
		return;
	}

	// Fast-forward 가능한지 확인
	if (isAncestor(currentHash, targetHash))
	{
		std::cout << "Fast-forward 병합을 수행합니다...\n";

		// 커밋 내용 복원 및 HEAD 갱신
		checkoutCommit(targetHash);
		updateBranchHead(targetHash);

		std::cout << "병합 완료: '" << targetBranch << "' -> '" << currentBranch << "'\n";
	}
	else
	{
		// 3-way 병합 수행 (충돌 가능성 포함)
		std::cout << "[3-way merge] 병합을 수행합니다...\n";
		mergeCommit(targetBranch);
	}
}

/**
* @brief 병합 커밋 생성 (다중 부모)
* 
* @param branchToMerge 병합할 대상 브랜치 이름
*/
void mergeCommit(const std::string& branchToMerge)
{
	std::string currentBranchHash = getCurrentBranchHash();
	std::string targetBrachHash = getBranchHash(branchToMerge);

	if (targetBrachHash.empty())
	{
		std::cerr << "병합할 브랜치 '" << branchToMerge << "' 는 커밋 이력이 없습니다.\n";
		return;
	}

	auto conflicts = detectConflicts(currentBranchHash, targetBrachHash);
	if (!conflicts.empty())
	{
		std::cout << "[경고] 충돌 발생! 수동으로 해결이 필요합니다.\n";

		// 현재 파일 백업
		backupCurrentFilesBeforeMerge(currentBranchHash);

		for (const auto& file : conflicts)
		{
			std::string baseA = readFileContent(".minigit\\commits\\" + currentBranchHash + "\\" + file);
			std::string baseB = readFileContent(".minigit\\commits\\" + targetBrachHash + "\\" + file);
			markConflict(file, baseA, baseB);
			std::cout << "- " << file << " <- 충돌 마킹 완료\n";
		}

		// 병합 상태 저장
		saveMergeState(currentBranchHash, targetBrachHash);

		std::cout << "충돌을 수동으로 해결한 후, `minigit commit`으로 병합을 완료하세요.\n";
		return; // 병합 중단
	}

	updateIndexAfterAutoMerge(currentBranchHash, targetBrachHash);

	// 병합 메세지 및 스냅샷 해시 생성
	std::string message = "Merge branch '" + branchToMerge + "'";
	mergeCommitFromState(currentBranchHash, targetBrachHash, message);
}

/**
 * @brief 병합 상태 파일을 기반으로 병합 커밋을 생성
 *
 * @param currentHash 현재 브랜치의 커밋 해시
 * @param targetHash 병합할 대상 브랜치의 커밋 해시
 */
void mergeCommitFromState(const std::string& currentHash, const std::string& targetHash, const std::string& message)
{
	// index snapshot 확보
	std::string snapshot = getCurrentIndexSnapshot();
	std::vector<std::string> snapshotLines = splitLines(snapshot);
	std::string commitHash = improvedHash(snapshotLines);
	std::string commitPath = ".minigit\\commits\\" + commitHash;

	if (!createCommitDirectory(commitHash))
	{
		std::cerr << "커밋 디렉토리 생성 실패\n";
		return;
	}

	// index 복사
	std::ofstream destIndex(commitPath + "\\index");
	if (!destIndex.is_open())
	{
		std::cerr << "index 복사 실패\n";
		return;
	}
	destIndex << snapshot;
	destIndex.close();

	// 파일 복사
	for (const auto& line : snapshotLines)
	{
		auto delim = line.find(":");
		if (delim == std::string::npos) continue;

		std::string filename = line.substr(0, delim);
		copyFileToCommit(filename, commitPath);
	}

	// 메타 작성
	writeMeta(commitPath, { currentHash, targetHash }, message);

	// HEAD 브랜치 업데이트
	updateBranchHead(commitHash);

	// index 초기화
	std::ofstream clearIndex(".minigit\\index", std::ios::trunc);
	if (!clearIndex.is_open())
		std::cerr << "index 초기화 실패\n";

	std::cout << "병합 커밋이 완료되었습니다.\n";
}
